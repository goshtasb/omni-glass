#!/usr/bin/env node
/**
 * Omni-Glass Plugin Template
 *
 * This is a minimal MCP server that communicates with Omni-Glass
 * over stdio using JSON-RPC 2.0 (newline-delimited JSON).
 *
 * To build your plugin:
 * 1. Edit omni-glass.plugin.json with your plugin's info and permissions
 * 2. Replace the TOOLS array below with your own tool definitions
 * 3. Implement your tool handlers in handleToolCall()
 * 4. Copy to ~/.config/omni-glass/plugins/com.your-name.your-plugin/
 * 5. Restart Omni-Glass — your plugin loads automatically
 *
 * Test standalone:
 *   echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}' | node index.js
 *   echo '{"jsonrpc":"2.0","id":1,"method":"tools/list","params":{}}' | node index.js
 */

const readline = require("readline");

// ═══════════════════════════════════════════════════════════════════
// Define your tools here. The LLM reads these descriptions to decide
// when to use your tool, so be specific about what it does.
// ═══════════════════════════════════════════════════════════════════

const TOOLS = [
  {
    name: "my_tool",
    description:
      "Describe what your tool does clearly — the LLM reads this " +
      "to decide when to offer it to the user.",
    inputSchema: {
      type: "object",
      properties: {
        text: {
          type: "string",
          description: "The snipped text or user input",
        },
      },
      required: ["text"],
    },
  },
];

// ═══════════════════════════════════════════════════════════════════
// Implement your tool handlers here.
// Each tool receives the arguments generated by the LLM from the
// user's snipped text or typed command.
// ═══════════════════════════════════════════════════════════════════

async function handleToolCall(name, args) {
  switch (name) {
    case "my_tool": {
      // Your logic here. Examples:
      // - Call an external API
      // - Process the text
      // - Look up data
      const result = `Received: ${args.text}`;
      return {
        content: [{ type: "text", text: result }],
        isError: false,
      };
    }
    default:
      throw new Error(`Unknown tool: ${name}`);
  }
}

// ═══════════════════════════════════════════════════════════════════
// MCP Server Boilerplate — you shouldn't need to edit below this line
// ═══════════════════════════════════════════════════════════════════

const SERVER_NAME = "my-plugin";
const SERVER_VERSION = "0.1.0";

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false,
});

function send(obj) {
  process.stdout.write(JSON.stringify(obj) + "\n");
}

function handleRequest(msg) {
  const { id, method, params } = msg;

  switch (method) {
    case "initialize":
      send({
        jsonrpc: "2.0",
        id,
        result: {
          protocolVersion: "2024-11-05",
          capabilities: { tools: {} },
          serverInfo: { name: SERVER_NAME, version: SERVER_VERSION },
        },
      });
      break;

    case "notifications/initialized":
      break;

    case "tools/list":
      send({ jsonrpc: "2.0", id, result: { tools: TOOLS } });
      break;

    case "tools/call":
      handleToolCall(params.name, params.arguments || {})
        .then((result) => send({ jsonrpc: "2.0", id, result }))
        .catch((err) =>
          send({
            jsonrpc: "2.0",
            id,
            result: {
              content: [{ type: "text", text: `Error: ${err.message}` }],
              isError: true,
            },
          })
        );
      break;

    default:
      if (id !== undefined) {
        send({
          jsonrpc: "2.0",
          id,
          error: { code: -32601, message: `Method not found: ${method}` },
        });
      }
      break;
  }
}

rl.on("line", (line) => {
  const trimmed = line.trim();
  if (!trimmed) return;
  try {
    handleRequest(JSON.parse(trimmed));
  } catch (e) {
    process.stderr.write(`[${SERVER_NAME}] Parse error: ${e.message}\n`);
  }
});

rl.on("close", () => process.exit(0));
